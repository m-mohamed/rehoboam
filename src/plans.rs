//! Plan discovery and viewer state
//!
//! Scans `~/.claude/plans/` for markdown plan files generated by Claude Code
//! during plan mode sessions.

use std::path::PathBuf;
use std::time::SystemTime;

/// A discovered plan file
#[derive(Debug, Clone)]
pub struct PlanEntry {
    /// Filename without extension (e.g., "vivid-kindling-pixel")
    pub name: String,
    /// Full path to the .md file
    pub path: PathBuf,
    /// Last modification time
    pub modified: SystemTime,
    /// File size in bytes
    pub size_bytes: u64,
}

/// State for the plan viewer overlay
#[derive(Default)]
pub struct PlanViewerState {
    /// All discovered plans, sorted by mtime desc
    pub plans: Vec<PlanEntry>,
    /// Currently selected plan in list mode
    pub selected_index: usize,
    /// true = reading a plan, false = browsing list
    pub viewing: bool,
    /// Vertical scroll offset in reader mode
    pub scroll_offset: u16,
    /// Total height of rendered markdown content (for scroll bounds)
    pub rendered_height: u16,
    /// Cached markdown content of the currently viewed plan
    pub content: String,
}

impl PlanViewerState {
    /// Load the selected plan's content from disk
    pub fn load_selected(&mut self) {
        if let Some(plan) = self.plans.get(self.selected_index) {
            self.content = std::fs::read_to_string(&plan.path).unwrap_or_default();
            self.scroll_offset = 0;
            self.rendered_height = 0;
            self.viewing = true;
        }
    }

    /// Move to next plan in reader mode (without going back to list)
    pub fn next_plan(&mut self) {
        if !self.plans.is_empty() {
            self.selected_index = (self.selected_index + 1) % self.plans.len();
            self.load_selected();
        }
    }

    /// Move to previous plan in reader mode
    pub fn prev_plan(&mut self) {
        if !self.plans.is_empty() {
            self.selected_index = if self.selected_index == 0 {
                self.plans.len() - 1
            } else {
                self.selected_index - 1
            };
            self.load_selected();
        }
    }
}

/// Scan ~/.claude/plans/ for markdown files, sorted by modification time (newest first)
pub fn discover_plans() -> Vec<PlanEntry> {
    let home = match std::env::var("HOME") {
        Ok(h) => h,
        Err(_) => return Vec::new(),
    };

    let plans_dir = PathBuf::from(home).join(".claude").join("plans");
    if !plans_dir.is_dir() {
        return Vec::new();
    }

    let mut plans: Vec<PlanEntry> = std::fs::read_dir(&plans_dir)
        .ok()
        .into_iter()
        .flatten()
        .filter_map(|entry| {
            let entry = entry.ok()?;
            let path = entry.path();
            if path.extension().and_then(|e| e.to_str()) != Some("md") {
                return None;
            }
            let metadata = entry.metadata().ok()?;
            let name = path
                .file_stem()
                .and_then(|s| s.to_str())
                .unwrap_or("unknown")
                .to_string();
            Some(PlanEntry {
                name,
                path,
                modified: metadata.modified().unwrap_or(SystemTime::UNIX_EPOCH),
                size_bytes: metadata.len(),
            })
        })
        .collect();

    plans.sort_by(|a, b| b.modified.cmp(&a.modified));
    plans
}

/// Format a SystemTime as a relative duration (e.g., "13m", "2d", "3h")
pub fn format_relative_time(time: SystemTime) -> String {
    let elapsed = time.elapsed().unwrap_or_default();
    let secs = elapsed.as_secs();
    if secs < 60 {
        format!("{secs}s")
    } else if secs < 3600 {
        format!("{}m", secs / 60)
    } else if secs < 86400 {
        format!("{}h", secs / 3600)
    } else {
        format!("{}d", secs / 86400)
    }
}

/// Format bytes as a human-readable size
pub fn format_size(bytes: u64) -> String {
    if bytes < 1024 {
        format!("{bytes}B")
    } else {
        format!("{}K", bytes / 1024)
    }
}
