//! Insights report parser for ~/.claude/usage-data/report.html
//!
//! Parses the self-contained HTML report generated by Claude Code's `/insights`
//! command. Extracts sections, prose text, and bar chart data using simple
//! string operations (no HTML rendering library needed).
//!
//! The HTML has clean semantic structure:
//! - `<h1>`, `<h2 id="section-*">` headings define sections
//! - `<div class="glance-title">` is a special section heading for "At a Glance"
//! - `<p>` for prose paragraphs
//! - Bar charts use multi-line `<div class="bar-row">` blocks:
//!   - `<div class="bar-label">Label</div>`
//!   - `<div class="bar-fill" style="width:XX%">` for the percentage
//!   - `<div class="bar-value">Value</div>`

use color_eyre::eyre;
use std::path::PathBuf;
use std::time::SystemTime;

/// Parsed insights report
#[derive(Debug, Clone)]
#[allow(dead_code)] // Fields used by UI renderer
pub struct InsightsReport {
    pub sections: Vec<InsightsSection>,
    pub generated_at: SystemTime,
}

/// A section of the insights report
#[derive(Debug, Clone)]
pub struct InsightsSection {
    /// Section heading (e.g., "At a Glance", "What You Work On")
    pub title: String,
    /// Stripped prose content
    pub content: String,
    /// Chart bars found in this section
    pub bars: Vec<InsightsBar>,
}

/// A single bar in a chart
#[derive(Debug, Clone)]
pub struct InsightsBar {
    pub label: String,
    pub value: String,
    pub percentage: f32,
}

pub struct InsightsDiscovery;

impl InsightsDiscovery {
    /// Read and parse ~/.claude/usage-data/report.html
    pub fn scan_report() -> eyre::Result<InsightsReport> {
        let path = Self::report_path()?;
        let metadata = std::fs::metadata(&path)?;
        let generated_at = metadata.modified().unwrap_or(SystemTime::UNIX_EPOCH);
        let content = std::fs::read_to_string(&path)?;

        let sections = Self::parse_html(&content);

        Ok(InsightsReport {
            sections,
            generated_at,
        })
    }

    fn parse_html(html: &str) -> Vec<InsightsSection> {
        let mut sections: Vec<InsightsSection> = Vec::new();
        let mut current_title = String::new();
        let mut current_content = String::new();
        let mut current_bars: Vec<InsightsBar> = Vec::new();
        let mut in_section = false;

        // Multi-line bar chart state: accumulate across bar-label, bar-fill, bar-value lines
        let mut pending_bar_label: Option<String> = None;
        let mut pending_bar_pct: Option<f32> = None;

        for line in html.lines() {
            let trimmed = line.trim();

            // Detect section headings: <h2 ...>Title</h2> or <h1>Title</h1>
            if let Some(title) = Self::extract_heading(trimmed, "h2")
                .or_else(|| Self::extract_heading(trimmed, "h1"))
            {
                // Save previous section
                if in_section && !current_title.is_empty() {
                    sections.push(InsightsSection {
                        title: current_title.clone(),
                        content: current_content.trim().to_string(),
                        bars: std::mem::take(&mut current_bars),
                    });
                }
                current_title = title;
                current_content.clear();
                pending_bar_label = None;
                pending_bar_pct = None;
                in_section = true;
                continue;
            }

            // Detect "At a Glance" which uses <div class="glance-title"> instead of <h2>
            if trimmed.contains("class=\"glance-title\"") {
                let text = Self::strip_tags(trimmed);
                let text = text.trim();
                if !text.is_empty() {
                    // Save previous section
                    if in_section && !current_title.is_empty() {
                        sections.push(InsightsSection {
                            title: current_title.clone(),
                            content: current_content.trim().to_string(),
                            bars: std::mem::take(&mut current_bars),
                        });
                    }
                    current_title = text.to_string();
                    current_content.clear();
                    pending_bar_label = None;
                    pending_bar_pct = None;
                    in_section = true;
                    continue;
                }
            }

            if !in_section {
                continue;
            }

            // Skip script and style blocks
            if trimmed.starts_with("<script") || trimmed.starts_with("<style") {
                continue;
            }

            // Multi-line bar chart extraction:
            // Pattern 1: <div class="bar-label">Label</div>
            if trimmed.contains("class=\"bar-label\"") {
                let text = Self::strip_tags(trimmed);
                let text = text.trim();
                if !text.is_empty() {
                    pending_bar_label = Some(text.to_string());
                }
                continue;
            }

            // Pattern 2: <div class="bar-fill" style="width:XX%...">
            if trimmed.contains("bar-fill") && trimmed.contains("width:") {
                if let Some(pct) = Self::extract_width_pct(trimmed) {
                    pending_bar_pct = Some(pct);
                }
                continue;
            }

            // Pattern 3: <div class="bar-value">Value</div>
            if trimmed.contains("class=\"bar-value\"") {
                let value_text = Self::strip_tags(trimmed).trim().to_string();
                // We have the value â€” try to emit a bar if we have label + pct
                if let (Some(label), Some(pct)) =
                    (pending_bar_label.take(), pending_bar_pct.take())
                {
                    current_bars.push(InsightsBar {
                        label,
                        value: value_text,
                        percentage: pct / 100.0,
                    });
                }
                continue;
            }

            // Skip bar-track and bar-row wrapper lines (no useful text)
            if trimmed.contains("class=\"bar-track\"") || trimmed.contains("class=\"bar-row\"") {
                continue;
            }

            // Strip HTML tags and collect prose
            let stripped = Self::strip_tags(trimmed);
            let stripped = stripped.trim();
            if !stripped.is_empty() {
                if !current_content.is_empty() {
                    current_content.push('\n');
                }
                current_content.push_str(stripped);
            }
        }

        // Save last section
        if in_section && !current_title.is_empty() {
            sections.push(InsightsSection {
                title: current_title,
                content: current_content.trim().to_string(),
                bars: current_bars,
            });
        }

        sections
    }

    /// Extract heading text from a tag like <h2 id="...">Title</h2>
    fn extract_heading(line: &str, tag: &str) -> Option<String> {
        let open = format!("<{}", tag);
        let close = format!("</{}>", tag);
        if !line.contains(&open) || !line.contains(&close) {
            return None;
        }
        // Find content between > and </hN>
        let after_open = line.find('>')? + 1;
        let before_close = line.find(&close)?;
        if after_open >= before_close {
            return None;
        }
        let inner = &line[after_open..before_close];
        let text = Self::strip_tags(inner).trim().to_string();
        if text.is_empty() {
            None
        } else {
            Some(text)
        }
    }

    /// Extract width percentage from a style attribute like style="width:85%;..."
    fn extract_width_pct(line: &str) -> Option<f32> {
        let width_idx = line.find("width:")?;
        let after_width = &line[width_idx + 6..];
        let pct_str: String = after_width
            .chars()
            .take_while(|c| c.is_ascii_digit() || *c == '.' || c.is_whitespace())
            .collect();
        pct_str.trim().parse().ok()
    }

    /// Strip HTML tags from a string
    fn strip_tags(s: &str) -> String {
        let mut result = String::with_capacity(s.len());
        let mut in_tag = false;
        for ch in s.chars() {
            match ch {
                '<' => in_tag = true,
                '>' => in_tag = false,
                _ if !in_tag => result.push(ch),
                _ => {}
            }
        }
        // Decode common HTML entities
        result
            .replace("&amp;", "&")
            .replace("&lt;", "<")
            .replace("&gt;", ">")
            .replace("&quot;", "\"")
            .replace("&#39;", "'")
            .replace("&apos;", "'")
            .replace("&nbsp;", " ")
            .replace("&mdash;", "\u{2014}")
            .replace("&ndash;", "\u{2013}")
            .replace("&hellip;", "\u{2026}")
            .replace("&lsquo;", "\u{2018}")
            .replace("&rsquo;", "\u{2019}")
            .replace("&ldquo;", "\u{201C}")
            .replace("&rdquo;", "\u{201D}")
    }

    fn report_path() -> eyre::Result<PathBuf> {
        let home =
            std::env::var("HOME").map_err(|_| eyre::eyre!("HOME not set"))?;
        Ok(PathBuf::from(home)
            .join(".claude")
            .join("usage-data")
            .join("report.html"))
    }
}
